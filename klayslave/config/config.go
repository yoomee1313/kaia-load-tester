package config

import (
	"context"
	"fmt"
	"log"
	"math/big"
	"net/http"
	"os"
	"strconv"
	"strings"
	"syscall"
	"time"

	"github.com/kaiachain/kaia-load-tester/klayslave/account"
	"github.com/kaiachain/kaia-load-tester/testcase"
	klay "github.com/kaiachain/kaia/client"
	"github.com/kaiachain/kaia/params"
	"github.com/urfave/cli"
)

type Config struct {
	// Directly from flags
	nUserForUnsigned    int
	nUserForSigned      int
	nUserForNewAccounts int
	activeUserPercent   int

	richWalletPrivateKey string
	tcNameList           []string
	tcWeights            []int

	auctionTargetTxTypeList []string

	chargeKLAYAmount  int
	chargeParallelNum int

	gEndpoint     string
	isLeaderSlave bool

	// Directly from connected node
	gasPrice *big.Int
	chainID  *big.Int
	baseFee  *big.Int

	// Additionally generated by this test code
	gCli *klay.Client
}

func NewConfig(ctx *cli.Context) *Config {
	var config Config
	config.setConfigsFromFlag(ctx)
	config.setConfigsFromNode()

	// setup default http client
	if tr, ok := http.DefaultTransport.(*http.Transport); ok {
		maxIdleConns := ctx.Int("tc.maxidleconns")
		tr.MaxIdleConns = maxIdleConns
		tr.MaxIdleConnsPerHost = maxIdleConns
	}
	config.setBoomerFlags(ctx)
	return &config
}

func (cfg *Config) setBoomerFlags(ctx *cli.Context) {
	maxRPC := ctx.Int("max-rps")
	masterHost := ctx.String("master-host")
	masterPort := ctx.Int("master-port")

	os.Args = append([]string{os.Args[0]},
		"--max-rps", fmt.Sprintf("%d", maxRPC),
		"--master-host", masterHost,
		"--master-port", fmt.Sprintf("%d", masterPort),
	)
}
func (cfg *Config) setConfigsFromFlag(ctx *cli.Context) {
	// Directly store the flag value
	cfg.gEndpoint = ctx.String("endpoint")
	cfg.nUserForSigned = ctx.Int("vusigned")
	cfg.nUserForUnsigned = ctx.Int("vuunsigned")
	cfg.nUserForNewAccounts = 5
	cfg.activeUserPercent = ctx.Int("activeUserPercent")
	cfg.chargeKLAYAmount = ctx.Int("charge")
	cfg.chargeParallelNum = ctx.Int("chargeParallel")
	cfg.richWalletPrivateKey = ctx.String("key")
	cfg.isLeaderSlave = ctx.Bool("leader")

	// Do not allow null richWalletPrivateKey
	if cfg.richWalletPrivateKey == "" {
		log.Fatal("key argument is not defined. You should set the key for the rich account.\n example) klaytc -key='2ef07640fd8d3f568c23185799ee92e0154bf08ccfe5c509466d1d40baca3430'")
	}
	// Do not allow the activeUserPercent which value is less than 0 or larger than 100
	if cfg.activeUserPercent > 100 || cfg.activeUserPercent <= 0 {
		log.Fatalf("ActiveAccountPercent should be between 0 and 100, but it is %v", cfg.activeUserPercent)
	}
	// Parse tcNames
	tcNames := ctx.String("tc")
	for _, name := range strings.Split(tcNames, ",") {
		// skip unknown tc
		if _, ok := testcase.TcList[name]; !ok {
			continue
		}
		// add known tc
		cfg.tcNameList = append(cfg.tcNameList, name)
	}

	// Parse tcWeights
	tcWeights := ctx.String("weights")
	for _, sWeight := range strings.Split(tcWeights, ",") {
		iWeight, err := strconv.Atoi(sWeight)
		if err != nil {
			cfg.tcWeights = []int{}
			fmt.Printf("Default weight will be used. (Failed to parse weights: %v: %s)\n", err, sWeight)
			break
		}
		cfg.tcWeights = append(cfg.tcWeights, iWeight)
	}

	// Parse auctionTargetTxTypeList when auctionBidTC or auctionRevertedBidTC is set
	if account.ContainsAnyInList(cfg.tcNameList, []string{"auctionBidTC", "auctionRevertedBidTC"}) {
		auctionTargetTxTypeList := ctx.String("auctionTargetTxTypeList")
		if len(auctionTargetTxTypeList) == 0 {
			log.Fatal("auctionTargetTxTypeList is not set. Please set auctionTargetTxTypeList.")
		}
		for _, sType := range strings.Split(auctionTargetTxTypeList, ",") {
			// skip unknown targetTxType
			if _, ok := account.TargetTxTypeList[sType]; !ok {
				continue
			}
			cfg.auctionTargetTxTypeList = append(cfg.auctionTargetTxTypeList, sType)
		}
	}

	if len(cfg.tcWeights) != 0 && len(cfg.tcWeights) != len(cfg.tcNameList) {
		cfg.tcWeights = []int{}
		fmt.Println("The length of --weights must match --tc.")
	}
	if len(cfg.tcNameList) == 0 {
		log.Fatal("No valid Tc is set. Please set valid TcList. \n Input tcList was '" + tcNames + "'")
	}

	maxRPC := ctx.Int("max-rps")
	if account.ContainsAnyInList(cfg.tcNameList, []string{"auctionBidTC", "auctionRevertedBidTC"}) && cfg.nUserForSigned < maxRPC {
		log.Fatal("When auctionBidTC or auctionRevertedBidTC is set, nUserForSigned must be larger than max-rps")
	}

	fmt.Println("Arguments are set like the following:")
	fmt.Printf("- Target EndPoint = %v\n", cfg.gEndpoint)
	fmt.Printf("- nUserForSigned = %v\n", cfg.nUserForSigned)
	fmt.Printf("- nUserForUnsigned = %v\n", cfg.nUserForUnsigned)
	fmt.Printf("- activeUserPercent = %v\n", cfg.activeUserPercent)
	fmt.Printf("- coinbasePrivatekey = %v\n", cfg.richWalletPrivateKey)
	fmt.Printf("- charging KLAY Amount = %v\n", cfg.chargeKLAYAmount)
	fmt.Printf("- chargeParallel = %v\n", cfg.chargeParallelNum)
	fmt.Printf("- tc = %v\n", cfg.tcNameList)
	fmt.Printf("- weights = %v\n", cfg.tcWeights)
	fmt.Printf("- auctionTargetTxTypeList = %v\n", cfg.auctionTargetTxTypeList)
}

func (cfg *Config) setConfigsFromNode() {
	var err error

	// Create Cli pool
	if cfg.gCli, err = klay.Dial(cfg.gEndpoint); err != nil {
		log.Fatalf("Failed to connect RPC: %v", err)
	}

	// TODO: refactor to updating gasPrice with goverance.magma.upperboundbasefee
	cfg.gasPrice = big.NewInt(750000000000)
	cfg.chainID = big.NewInt(2018)
	cfg.baseFee = big.NewInt(0)

	// update ChainID
	fmt.Println("Updating ChainID from RPC")
	for {
		ctx := context.Background()
		chainID, err := cfg.gCli.ChainID(ctx)

		if err == nil {
			fmt.Println("chainID :", chainID)
			cfg.chainID = chainID
			break
		}
		fmt.Println("Retrying updating chainID... ERR: ", err)

		time.Sleep(2 * time.Second)
	}

	// update
	// TODO: Uncomment below when klaytn 1.8.0 is released.
	//for {
	//	ctx := context.Background()
	//	h, err := gCli.HeaderByNumber(ctx, nil)
	//
	//	if err == nil {
	//		baseFee = h.BaseFee
	//		fmt.Println("base fee :", baseFee.String())
	//		break
	//	}
	//	fmt.Println("Retrying updating BaseFee... ERR: ", err)
	//
	//	time.Sleep(2 * time.Second)
	//}
}

func (cfg *Config) GetExtendedTasks() []*testcase.ExtendedTask {
	var tasks []*testcase.ExtendedTask
	for i, name := range cfg.tcNameList {
		if task := testcase.TcList[name]; task != nil { // if unknown, skip.
			var weight int = task.Weight
			if len(cfg.tcWeights) > i {
				weight = cfg.tcWeights[i]
			}
			tasks = append(tasks, &testcase.ExtendedTask{Name: task.Name, Weight: weight, Init: task.Init, Run: task.Run, TestContracts: task.TestContracts})
		}
	}
	return tasks
}

func (cfg *Config) GetChainID() *big.Int                 { return cfg.chainID }
func (cfg *Config) GetGasPrice() *big.Int                { return cfg.gasPrice }
func (cfg *Config) GetBaseFee() *big.Int                 { return cfg.baseFee }
func (cfg *Config) GetNUserForUnsigned() int             { return cfg.nUserForUnsigned }
func (cfg *Config) GetNUserForSigned() int               { return cfg.nUserForSigned }
func (cfg *Config) GetNUserForNewAccounts() int          { return cfg.nUserForNewAccounts }
func (cfg *Config) GetGEndpoint() string                 { return cfg.gEndpoint }
func (cfg *Config) GetActiveUserPercent() int            { return cfg.activeUserPercent }
func (cfg *Config) GetTcStrList() []string               { return cfg.tcNameList }
func (cfg *Config) GetAuctionTargetTxTypeList() []string { return cfg.auctionTargetTxTypeList }
func (cfg *Config) GetRichWalletPrivateKey() string      { return cfg.richWalletPrivateKey }
func (cfg *Config) GetGCli() *klay.Client                { return cfg.gCli }
func (cfg *Config) GetChargeParallelNum() int            { return cfg.chargeParallelNum }
func (cfg *Config) IsLeaderSlave() bool                  { return cfg.isLeaderSlave }
func (cfg *Config) GetChargeValue() *big.Int {
	return new(big.Int).Mul(big.NewInt(int64(cfg.chargeKLAYAmount)), big.NewInt(params.KAIA))
}
func (cfg *Config) GetTotalChargeValue() *big.Int {
	return new(big.Int).Mul(cfg.GetChargeValue(), big.NewInt(int64(cfg.nUserForUnsigned+cfg.nUserForSigned+cfg.nUserForNewAccounts+int(account.ContractEnd))))
}

// Flags TODO-kaia-load-tester: add env.var
var Flags = []cli.Flag{
	cli.StringFlag{Name: "endpoint", Value: "http://localhost:8551", Usage: "Target EndPoint"},
	cli.IntFlag{Name: "vusigned", Value: 5, Usage: "num of test account for signed Tx TC"},
	cli.IntFlag{Name: "vuunsigned", Value: 5, Usage: "num of test account for unsigned Tx TC"},
	//cli.IntFlag{Name: "acc.nUserForNewAccounts", Value: 5, Usage: "num of new accounts"}, // TODO-kaia-load-tester: find out what this value for
	cli.IntFlag{Name: "activeUserPercent", Value: 100, Usage: "percent of active accounts"},
	cli.IntFlag{Name: "charge", Value: 1000000000, Usage: "charging amount for each test account in KLAY"},
	cli.IntFlag{Name: "chargeParallel", Value: 0, Usage: "number of parallel transactions for charging accounts (0 = auto-detect based on CPU cores)"},
	cli.IntFlag{Name: "maxidleconns", Value: 100, Usage: "maximum number of idle connections in default http client"},
	cli.StringFlag{Name: "key", Usage: "private key of rich account for kaia charging of test accounts"},
	cli.StringFlag{Name: "tc", Value: "", Usage: "tasks which user want to run, multiple tasks are separated by comma."},
	cli.StringFlag{Name: "weights", Value: "", Usage: "weights which user want to run, multiple weights are separated by comma."},
	cli.StringFlag{Name: "auctionTargetTxTypeList", Value: "", Usage: "auction target tx types which user want to run, multiple target tx types are separated by comma."},
	cli.StringFlag{Name: "testTokenAddr", Value: "", Usage: "Address of TestToken Contract"},
	cli.StringFlag{Name: "gsrAddr", Value: "", Usage: "Address of Gasless Swap Router"},
	cli.BoolFlag{Name: "leader", Usage: "If true, this slave will deploy contracts"},
}

var BoomerFlags = []cli.Flag{
	cli.IntFlag{Name: "max-rps", Usage: "Maximum number of RPC calls"},
	cli.StringFlag{Name: "master-host", Usage: "Url for the locust master"},
	cli.StringFlag{Name: "master-port", Usage: "Port for the locust master"},
}

func SetRLimit() error {
	var rLimit syscall.Rlimit
	// TODO-kaia-load-tester: no need
	err := syscall.Getrlimit(syscall.RLIMIT_NOFILE, &rLimit)
	if err != nil {
		return err
	}
	rLimit.Cur = 1024 * 400
	err = syscall.Setrlimit(syscall.RLIMIT_NOFILE, &rLimit)
	if err != nil {
		return err
	}
	return nil
}
